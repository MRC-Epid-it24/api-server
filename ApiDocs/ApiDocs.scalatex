@import Main._
@import apidocs.IntroExamples
@import apidocs.SigninExamples

@sect{Intake24 JSON API}

  @p
    @i{Version 2.11.0}

  @p
    Intake24 (@a("https://intake24.co.uk", href := "https://intake24.co.uk")) is a self-completed computerised dietary recall system 
    based on multiple-pass 24-hour recall. The online system offers similar data quality to interviewer-led recalls at a significantly lower cost.
    
  @p
    The Intake24 API is designed to provide access to the underlying food database used by the system in order to build custom
    applications that require estimation of the nutrient intake.
    
  @sect{Introduction}
    @p
      Intake24 API uses several data encoding conventions that are slightly different from what is usually encountered
      in other JSON-based APIs. These conventions are explained below and are used throughout the system.
    @sect{Optional type}
      @p
        Optional values are encoded as JSON arrays with either zero elements (when the value is not present):
          @hl.js{@IntroExamples.optionalStringMissing}
        or exactly one element (when the value is present):
          @hl.js{@IntroExamples.optionalStringPresent}
        as opposed to the more popular convention of omitting the optional fields altogether in case the value is missing.
      @p
        The reason behind such encoding is that optional types in Intake24 can form a part of a more complex type. For instance,
        a type which is either an optional string, or a number (see also the explanation of the Either type below) is encoded as
        follows:
          @hl.js{@IntroExamples.eitherOption}
        the missing left value could potentially be encoded as @b{null}, but that would be inconsistent with the case where the
        optional value is a field and it would also make it impossible to tell which values are intended to be optional. Having
        an explicit optional value encoding allows to assume that no value can ever be @b{null} and avoid unnecessary nullness checking
        and null pointer exceptions.
      @p
        Another less practical reason for this encoding is that it would otherwise be impossible to encode a nested optional value as a field.
        In this example, "value" is an optional value that is present that wraps another optional value that is missing:
          @hl.js{@IntroExamples.nestedOptionMissingInner}
        It would be impossible to encode the presence of the outer value using field omission if the inner value was missing.
      @p
        Of course such types are unlikely to be used in practice, however they must still be possible to encode
        to ensure the robustness of the server-side automated JSON mapping system. See @a("https://github.com/lihaoyi/upickle-pprint/issues/75", href := "https://github.com/lihaoyi/upickle-pprint/issues/75") for
        further discussion.

    @sect{Either type}
      @p
        The Either type represents values with two possibilities, traditionally called left and right. The Either type is encoded as a JSON array of
        exactly 2 elements, where the first element is either 0 or 1. If the first element is 0, then the second element must be parsed as a value of
        the left type. If it is 1, then the second element must be parsed as the right type.
      @p
        For instance, @b{foodOrCategory} could be either a food header or a category header. These types are incompatible and must be handled differently. If it is a food header (left type),
        it will be encoded as follows:
          @hl.js{@IntroExamples.eitherFood}
        and if it is a category header (right type) it will be encoded like this:
          @hl.js{@IntroExamples.eitherCategory}

  @sect{Authentication}
    @p
      Intake24 uses a two-stage authentication system that is based on two classes of authentication tokens called refresh and access tokens.
    @p
      @b{Refresh tokens} are issued through a credentials (i.e. user name and password) based authentication procedure. Refresh tokens are similar
      to the traditional API keys in that they are long-lived and must be stored securely by the API client for long-term use once the credentials
      have been authenticated.
    @p
      @b{Access tokens} are required to access the actual API endpoints. Access tokens are obtained by presenting a valid refresh token to the server.
      They are short-lived; the exact validity period depends on the server configuration but is typically 10 minutes up to 2 hours. They cannot be
      extended and a new token must be obtained if the previous one has expired.
    @p
      See @a("https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/", href:="https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/")
      for an in-depth explanation of the refresh/access token system.
    @sect{Access token expiration}
      @p
        The client applicaton must expect that an access token can expire at any time and consequently any request can be denied with the
        @hl.asciidoc{HTTP 401 Unauthorized} code. In that case, the application must obtain a new access token and retry the request.
    @sect{Signing in}
      To obtain a @b{refresh} token, @b{POST} a sign in request to
        @p
          @hl.asciidoc{/signin}
        @p
          with the following JSON body:
            @hl.js{@SigninExamples.signInRequest}
        @p
          where
        @ul
          @li
            @b{survey_id} is the optional survey identifier for the user that you are signing in as (user names are unique w.r.t individual surveys, but not system-wide).
            This field should contain an empty value if the user you would like to sign in as is a system-wide user, such as an administrator (see @sect.ref{Optional type}).
          @li
            @b{username} is the unique user ID
          @li
            @b{password} is the user's password
        @sect{Response}
          @ul
            @li
              @p @hl.asciidoc{HTTP 200 OK}: successful authentication.
              @p The body is a JSON object containing a single field, @b{refreshToken}: @hl.js{@SigninExamples.signInResult}
              @p The application must cache the refresh token securely for long-term use.
            @li
              @p @hl.asciidoc{HTTP 401 Unauthorized}: the provided credentials were not recognised.
    @sect{Refreshing the access token}
      To obtain a new @b{access} token, @b{POST} a refresh request to
        @p
          @hl.asciidoc{/refresh}
        @p
          with an empty body and the value of a valid @b{refresh} token in the @hl.asciidoc{X-Auth-Token} header.
        @sect{Response}
          @ul
            @li
              @p @hl.asciidoc{HTTP 200 OK}: successful access token renewal.
              @p The body is JSON object containing a single field, @b{accessToken}: @hl.js{@SigninExamples.refreshResult}
              @p
                The application must cache and reuse the access token until it is rejected with the @hl.asciidoc{HTTP 401 Unauthorized} code, in which case the application must request
                a new access token using this end-point and retry the affected request. Existing access tokens are automatically expired and do not need to be de-activated explicitly.
            @li
              @p @hl.asciidoc{HTTP 401 Unauthorized}: the refresh token is missing or invalid.
    @sect{Using the access token}
      @p Any API request that requires authentication (all of them at the moment) must include the access token exactly as returned by the server.
      @p The token should be sent in the @hl.asciidoc{X-Auth-Token} header.
      @p The @hl.asciidoc{HTTP 401 Unauthorized} response must be expected for any API request. To correctly handle this response, the application must request a new access token
         and retry the request.
